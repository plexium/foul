<?php/*   Package: Foul      Form Validation Language Version 2 for PHP      Copyright (c) 2012 Bryan English (bryan@bluelinecity.com)   *//*   Class: Foul*/class Foul {   public static $STATES = array('AL','AK','AS','AZ','AR','CA','CO','CT','DE','DC','FM','FL','GA','GU','HI','ID','IL','IN','IA','KS','KY','LA','ME','MH','MD','MA','MI','MN','MS','MO','MT','NE','NV','NH','NJ','NM','NY','NC','ND','MP','OH','OK','OR','PW','PA','PR','RI','SC','SD','TN','TX','UT','VT','VI','VA','WA','WV','WI','WY','AE','AA','AE','AE','AE','AP');   public static $STATE_ZIP_LOOKUP = array('FM'=>'969','AS'=>'96799','GU'=>'969','AL'=>'35-36','AK'=>'995-999','AZ'=>'85-86','AR'=>'716-729','CA'=>'900-961','CO'=>'80-81','CT'=>'06','DE'=>'197-199','DC'=>'200-205','FL'=>'32-34','GA'=>'30-31','HI'=>'967-968','ID'=>'832-839','IL'=>'60-62','IN'=>'46-47','IA'=>'50-52','KS'=>'66-67','KY'=>'40-42','LA'=>'700-715','ME'=>'039-049','MH'=>'969','MD'=>'206-219','MA'=>'010-027','MI'=>'48-49','MN'=>'55-56','MS'=>'386-399','MO'=>'63-65','MT'=>'59','NE'=>'68-69','NV'=>'89','NH'=>'030-038','NJ'=>'07-08','NM'=>'87-88','NY'=>'10-14','NC'=>'27-28','ND'=>'58','MP'=>'969','OH'=>'43-45','OK'=>'73-73','OR'=>'97','PW'=>'969','PA'=>'150-196','PR'=>'006-009','RI'=>'028-029','SC'=>'29','SD'=>'57','TN'=>'370-385','TX'=>'75-79','UT'=>'84','VT'=>'05','VI'=>'006-009','VA'=>'220-246','WA'=>'980-994','WV'=>'247-269','WI'=>'53-54','WY'=>'820-831','AE'=>'09','AA'=>'340','AP'=>'962-966');   public static $IMG_FILE_EXT = array('ani','b3d','bmp','dib','cam','clp','crw','cr2','cur','dcm','acr','ima','dcx','dds','djvu','iw44','ecw','emf','eps','fpx','fsh','g3','gif','icl','ico','ics','ids','iff','lbm','img','jp2','jpc','j2k','jpf','jpg','jpeg','jpe','jpm','kdc','ldf','lwf','mng','jng','nlm','nol','ngg','gsm','pbm','pcd','pcx','pgm','png','ppm','psd','psp','ras','sun','raw','rle','sff','sfw','sgi','rgb','sid','swf','tga','tif','tiff','wbmp','wmf','xbm','xpm');   public static $EXE_FILE_EXT = array('ade','adp','bas','chm','cmd','cpl','crt','hlp','hta','inf','ins','isp','jse','lnk','mdb','mde','msc','msi','msp','mst','ocx','pcd','pif','pot','ppt','sct','shb','shs','sys','url','vb','vbe','vbs','wsc','wsf','exe','js','vbs','scr','com','bat','wsh','reg','dll');		   public static $MAGIC_MESSAGES = array(      "^\~([^~]+)\~$" => "[[field]] is a required field.",      "( is)? (null|empty|blank)" => "[[field]] is a required field.",      " not email" => "Please enter a valid email address.",      " not (date\-us|date\-us\-y2k)" => "Please enter a valid date in the form of mm/dd/yyyy.",      " not zip-state-match(\-us)?" => "Please verify the zip code you entered is correct for the state.",      " not (zip(\-us)?|zipcode(\-us)?)" => "Please enter a valid ZIP.",      " not (state(\-us)?|postalcode(\-us)?)" => "Please enter a valid state.",      " not url\-http" => "Please enter a valid url in the form of http://domain/path/file",      " not url\-ftp" => "Please enter a valid ftp url in the form of ftp://[user:pass@]domain/path/file",      " not url" => "Please enter a valid url in the form of protocol://[user:pass@]domain/path/file",      " not (ssn|social\-security\-number)" => "Please specify a valid social security number.",      " not phone\-us" => "Please specify a valid U.S. phone number.",   );      /*    * Method: create    */   public static function create( $data )   {      return new FoulTestGroup( $data );   }      /*    * Method: isEmpty    */   public static function isEmpty( $str )   {      return ( $str === null || $str == '' );   }            /*    * Method: onion    */   public static function onion( $str, $left = '(', $right = ')', $index = null)   {      $s = 0;      $tally = -1;      $found = array();            for ( $cnt = 0 ; $cnt < strlen($str); $cnt++ )      {         if ( $str{$cnt} == $left && $str{$cnt-1} != '\\' )         {            if ( $tally == -1 )            {               $s = $cnt+1;               $tally = 1;            }            else            {               $tally++;            }         }                  if ( $tally != -1 && $str{$cnt} == $right && $str{$cnt-1} != '\\') $tally--;                  if ( $tally == 0 )         {            $found[] = substr($str,$s,$cnt-$s);            $tally = -1;         }      }            if ( $index === null )          return $found;      else         return $found[$index];   }}/* * Class: Foul Context * Responsible for storing variables for evanulation throughout a group test. */class FoulContext{   public $variables = array();      /*    * Method: check    * Check a context variable and save it if it's new.    */   public function check( $c )   {      foreach ( $this->variables as $i => $val )         if ( $val === $c ) return $i;            $this->variables[] = $c;      return count($this->variables) - 1;   }      /*    * Method: get    * Returns a saved context variable    */   public function get( $i )   {      if ( is_string($i) )         $i = str_replace('#','',$i);            return $this->variables[intval($i)];   }}/* * Class: FoulTest   Represents a single validation test which may or may not result in a single error message. */class FoulTest{   /*      Public: $group      Reference to the group this test is a part of.   */   public $group;   /*      Public: $context      Reference to the context object for retrieving vars and literals   */      public $context;      /*      Public: $message      String, error message to respond with if the test fails   */   public $message;      /*      Public: $test      String, validation test   */   public $test;      /*      Public: $compiled      String, the compiled test with vars removed, deadwood words etc.   */   public $compiled;   /*      Public: $field_name      First field appearing in the test.   */   public $field_name;        /*      Public $canceled      Boolean, if this test has been canceled due to something outside of the validation test   */   public $canceled;            /*      Method: __construct            Parameters:         $group - Reference to the <FoulTestGroup> object         $test - String, validation statement         $message - String, error message to report on failure   */   public function __construct( &$group, $test, $message )   {      $this->group = $group;      $this->test = $test;      $this->message = $message;            preg_match('/^\s*\~([^~]+)\~/', $test, $matches);      $this->field_name = $matches[1];            $this->canceled = false;               }       /*      Method: run      Run the validation test and returns a boolean            Parameters:         $context - reference to the context object for var referencing            Return:         boolean - if the test passes   */   public function run( &$context )   {      $this->canceled = false;      $this->context = $context;      $this->compile();      return ( $this->parse($this->compiled) );   }        /*      Method: compile      Nabs any form references and literals from the test string so parsing can do its job. This      gathers all the actual values for the tests.               */   public function compile()   {      //strip out variables and literals//	      $matches = array();      $val_re = '/(\\~|\\\'|\\")(.*?)(\\1)/';      $num_re = '/(?:^|\s|\()(\d+)(?:\s|\)|$)/';            $this->compiled = $this->test;      $offset = 0;            //foreach potential value referece//      while ( preg_match($val_re, $this->test, $matches, PREG_OFFSET_CAPTURE, $offset ) )      {		                  if ( $matches[1][0] == '~') //fetch value from form         {         	//check for var modifier//         	if ( preg_match('/\:length/',$matches[2][0]) )         	   $val = strlen( $this->group->get( str_replace(':length', $matches[2][0])) );         	else         	   $val = $this->group->get( $matches[2][0] );         }          else          {            $val = $matches[2][0];                                 }		      	         $this->compiled = str_replace( $matches[0][0], '##' . $this->context->check( $val ), $this->compiled);         $offset = $matches[0][1] + strlen($matches[0][0]);      }            $offset = 0;      //foreach number literal//      while ( preg_match($num_re, $this->test, $matches, PREG_OFFSET_CAPTURE, $offset ) )      {         $this->compiled = str_replace( $matches[1][0], '##' . $this->context->check( $matches[1][0] ), $this->compiled);		         $offset = $matches[0][1] + strlen($matches[0][0]) - 1;		      }         }         /*      Method: evaluate      Evaluates a single, non-compound test statement.            Parameters:         $str - test clause to evaluate            Return:         boolean - if the test passes or not   */   public function evaluate( $str )   {      $negate = preg_match('/ not |\!|\!\=|\<\>| is\-not /i', $str );      while ( preg_match('/\s(is|has|\=\=|does|equal\-to|same\-as|a|not|\!|\!\=|\<\>|is\-not)\s/i', $str ) )      {         $str = preg_replace('/\s(is|has|\=\=|does|equal\-to|same\-as|a|not|\!|\!\=|\<\>|is\-not)\s/i',' ', $str );      }            $params = preg_split('/\s+/',$str);		      $subj = array_shift($params);      $test = array_shift($params);		      //if two vars assume equality test//      if ( preg_match('/\\#\\#/',$test) )      {         $params[0] = $test;         $test = '=';      }            //TODO need to check for test existance at some point            $result = $this->test( $test, $subj, $params );            if ( $result === null ) $this->canceled = true;            if ( $this->canceled ) return false;				            return ( $negate ) ? !$result : $result;         }           /*      Method: parse      Parses a foul test string recursivly evaluating boolean conditions            Parameters:         $str - compiled test statement to parse and separate into clauses            Return:         boolean - if the test fails or not.   */   public function parse( $str )   {      $left = null;      $right = null;      $bool = null;            $result = false;      $str = trim($str);            //check for paranthesis//      if ( $str{0} == '(' )      {         $left = Foul::onion($str,'(',')',0);                           $right = substr( $str, strpos($str,$left) + strlen($left) );         $result = $this->parse( $left );      }      else      {         preg_match('/.*?(?= and | or |$)/i', $str, $matches );         $left = $matches[0];         $right = substr( $str, strpos($str,$left) + strlen($left) );                  $result = $this->evaluate($left);         if ( $result === null ) $this->canceled = true;      }            if ( preg_match('/ or | and /i', $right, $matches ) )      {         $bool = $matches[0];               $right = substr( $right, strpos( $right,$bool) + strlen($bool) );                  //get recursive//         switch( trim($bool) )         {            case "AND":            case "and":               return ( $result && $this->parse($right) );            case "OR":            case "or":               return ( $result || $this->parse($right) );         }      }      else      {         return $result;      }         }         /*      Method: test      Apply a validation test using the parameters given            Parameters:         $type - String, type of test to conduct         $subj - String, subject of the test         $params - Array, additional parameters for use by the test               Return:         boolean - results of the test   */      public function test( $type, $subj, $params )      {      switch( $type )      {         case '=':            return $this->context->get($subj) === $this->context->get($params[0]);         break;                  case 'null':         case 'blank':         case 'none':         case 'empty':            return Foul::isEmpty( $this->context->get($subj) );         break;                  case 'number':         case 'numeric':         case 'integer':            $val = $this->context->get($subj);            if ( $this->canceled || Foul::isEmpty($val) ) return null;            return is_numeric($val);         break;         case 'decimal':         case 'float':            $val = $this->context->get($subj);            if ( $this->canceled || Foul::isEmpty($val) ) return null;                        return ( $val == (string)(float)$val );         break;                  case 'range':         case 'between':         case 'in-between':            $val = $this->context->get($subj);            if ( $this->canceled || Foul::isEmpty($val) ) return null;			$val = floatval($val);			return ( $val >= floatval($this->context->get( $params[0])) && $val <= floatval($this->context->get($params[1])) );                                 break;         case 'greater-than':         case '>':            $val = $this->context->get($subj);            if ( $this->canceled || Foul::isEmpty($val) || !is_numeric($val) ) return null;						return ( floatval($val) >= floatval($this->context->get( $params[0])) );                                 break;         case 'less-than':         case '<':            $val = $this->context->get($subj);            if ( $this->canceled || Foul::isEmpty($val) || !is_numeric($val) ) return null;						return ( floatval($val) <= floatval($this->context->get( $params[0])) );                                 break;         case 'e-mail':         case 'email':            $val = $this->context->get($subj);            if ( $this->canceled || Foul::isEmpty($val) ) return null;			return ( preg_match('/^.+\@..+\..+/', $val ) );                                 break;         case 'spaces':         case 'blanks':            $val = $this->context->get($subj);            if ( $this->canceled || Foul::isEmpty($val) ) return null;			return ( preg_match('/\s/', $val ) );                                 break;                case 'url':            $val = $this->context->get($subj);            if ( $this->canceled || Foul::isEmpty($val) ) return null;			return ( preg_match('/^(https?|ftp|news)\:\/\/([\S]+\:[\S]+\@)?[a-zA-Z0-9\.\-]+(\/[\S]*)?$/', $val ) );                                 break;         case 'http-url':         case 'url-http':            $val = $this->context->get($subj);            if ( $this->canceled || Foul::isEmpty($val) ) return null;			return ( preg_match('/^https?\:\/\/([\S]+\:[\S]+\@)?[a-zA-Z0-9\.\-]+(\/[\S]*)?$/', $val ) );                                 break;         case 'ftp-url':         case 'url-ftp':            $val = $this->context->get($subj);            if ( $this->canceled || Foul::isEmpty($val) ) return null;			return ( preg_match('/^ftp\:\/\/([\S]+\:[\S]+\@)?[a-zA-Z0-9\.\-]+(\/[\S]*)?$/', $val ) );                                 break;         case 'zipcode-us':         case 'zipcode':         case 'zip-us':         case 'zip':            $val = $this->context->get($subj);            if ( $this->canceled || Foul::isEmpty($val) ) return null;			return ( preg_match('/^\d{5}(\-\d{4})?$/', $val ) );                                 break;         case 'state-us':         case 'state':            $val = $this->context->get($subj);            if ( $this->canceled || Foul::isEmpty($val) ) return null;			return ( preg_match('/^(' . implode('|', Foul::$STATES ) .  ')$/i', $val ) );                                 break;         case 'zip-matches-state':            $val = $this->context->get($subj);            if ( $this->canceled || Foul::isEmpty($val) ) return null;                        $state = strtoupper($this->context->get($params[0]));                  if ( Foul::isEmpty($state) ) return null;                        $range = explode('-', Foul::$STATE_ZIP_LOOKUP[$state]);            $digits = strlen($range[0]);                        $zip = intval(substr($val,0,$digits));                        if (count($range) > 1){               return ($zip >= intval($range[0]) && $zip <= intval($range[1]));            } else {               return ($zip == intval($range[0]));            }         break;	                  case 'ssn':            $val = $this->context->get($subj);            if ( $this->canceled || Foul::isEmpty($val) ) return null;			return ( preg_match('/^\d\d\d\-\d\d\-\d\d\d\d$/',$val) &&               !preg_match('/(^000)|(\-00\-)|(0000$)/',$val) &&               !preg_match('/987\-65\-432[0-9]/',$val));                                 break;         case 'file-type':            $val = $this->context->get($subj);            if ( $this->canceled || Foul::isEmpty($val) ) return null;            $files = preg_split('/[\s,]/', $this->context->get($params[0]));                        foreach ( $files as $file )               if ( preg_match('/\.'. $file .'$/i', $val))                   return true;                        return false;         break;         case 'file-type-image':            $val = $this->context->get($subj);            if ( $this->canceled || Foul::isEmpty($val) ) return null;                        foreach ( Foul::$IMG_FILE_EXT as $file )               if ( preg_match('/\.'. $file .'$/i', $val))                   return true;                        return false;         break;         case 'file-type-executable':            $val = $this->context->get($subj);            if ( $this->canceled || Foul::isEmpty($val) ) return null;                        foreach ( Foul::$EXE_FILE_EXT as $file )               if ( preg_match('/\.'. $file .'$/i', $val))                   return true;                        return false;         break;         case 'valid-credit-card':         case 'valid-cc':         case 'vcc':            $val = $this->context->get($subj);            if ( $this->canceled || Foul::isEmpty($val) ) return null;                        $val = preg_replace('/\D/','',$val);            if ( strlen($val) > 19) return false;                              if (!is_numeric($val)) return false;      		            $sum = 0;             $mul = 1;             $l = strlen($val);            for ($i = 0; $i < l; $i++) {               $digit = substr($val,$l-$i-1,$l-$i);               $tproduct = intval($digit) * $mul;               if ($tproduct >= 10)                  $sum += ($tproduct % 10) + 1;               else                  $sum += $tproduct;               if ($mul == 1)                  $mul++;               else                  $mul--;               }                        return (($sum % 10) == 0);                     break;                  case 'date':         case 'date-us':            $val = $this->context->get($subj);            if ( $this->canceled || Foul::isEmpty($val) ) return null;            if ( preg_match('/\d\d?\/\d\d?\/\d{2,4}/',$val) )      		{               //logic validation//               preg_match('/(\d\d?)\/(\d\d?)\/(\d{2,4})/',$val,$pcs);      		   $time = strtotime($val);                     		   if ( intval($pcs[1]) == intval(date('n',$time)) &&       		      intval($pcs[2]) == intval(date('j',$time)) &&      		      (( strlen($pcs[3]) == 2 && intval($pcs[3]) == intval(date('y',$time)) ) ||      		      ( strlen($pcs[3]) == 4 && intval($pcs[3]) == intval(date('Y',$time)) ))      		   ) return true;                           }            return false;                                 break;                  case 'date-us-y2k':            $val = $this->context->get($subj);            if ( $this->canceled || Foul::isEmpty($val) ) return null;            if ( preg_match('/\d\d?\/\d\d?\/\d{4}/',$val) )      		{               //logic validation//               preg_match('/(\d\d?)\/(\d\d?)\/(\d{4})/',$val,$pcs);      		   $time = strtotime($val);                     		   if ( intval($pcs[1]) == intval(date('n',$time)) &&       		      intval($pcs[2]) == intval(date('j',$time)) &&      		            		      intval($pcs[3]) == intval(date('Y',$time))      		   ) return true;                           }            return false;                                 break;                  case 'password':            $val = $this->context->get($subj);            if ( $this->canceled || Foul::isEmpty($val) ) return null;                        return ( !preg_match('/\t|\n|\r/',$val) && strlen($val) >= 8 );                     break;                  case 'password-strength':            $val = $this->context->get($subj);            if ( $this->canceled || Foul::isEmpty($val) ) return null;            $pw = (string)$val;                        //length of the password            $pwlength = strlen($pw);            if ( $pwlength > 5)              $pwlength = 5;                              //use of numbers in the password            $numnumeric = preg_replace('/[0-9]/', "", $pw);            $numeric = strlen($pw) - strlen($numnumeric);            if ($numeric > 3)              $numeric=3;                     //use of symbols in the password            $symbols = preg_replace('/\W/','',$pw);            $numsymbols = strlen($pw) - strlen($symbols);            if ( $numsymbols > 3)              $numsymbols = 3;                     //use of uppercase in the password            $numupper = preg_replace('/[A-Z]/', "", $pw);            $upper = strlen($pw) - strlen($numupper);            if ( $upper > 3 )              $upper = 3;                              $pwstrength = (($pwlength*10)-20) + ($numeric*10) + ($numsymbols*15) + ($upper*10);                     // make sure we're give a value between 0 and 100            if ( $pwstrength < 0 ) {              $pwstrength = 0;            }                     if ( $pwstrength > 100 ) {              $pwstrength = 100;            }                     return ( $pwstrength > $this->context->get($params[0]) ) ;         break;                  case 'in':            $val = $this->context->get($subj);            if ( $this->canceled || Foul::isEmpty($val) ) return null;            for ( $c = 0; $c < count($params); $c++ )               if ( $this->context->get( $params[$c]) == $val )                  return true;                        return false;         break;                  case 'phone':         case 'phone-us':            $val = $this->context->get($subj);            if ( $this->canceled || Foul::isEmpty($val) ) return null;			return ( preg_match('/^((1[\s\-\.]?)?\(?\d{3}\)?[\s\-\.]?)?\d{3}[\s\-\.]?\d{4}$/', $val ) );                                             break;                           default:            //look for custom tests//            echo 'Unknown test: ' . $type;            $this->canceled = true;         break;      }   }       }/*   Class: FoulTestGroup   Groups a set of FoulTests....typically a single form. Takes a single parameter, the posted data to validate.*/class FoulTestGroup{   public $custom_tests = array();      public $tests = array();      public $formats = array();         public $data = array();   public $errors = array();         public function __construct( $data )   {      $this->data = $data;   }   /*    * Method: get    */   public function get( $name )   {      return isset($this->data[$name]) ? $this->data[$name] : null;   }      /*    * Method: when    */   public function when( $test, $message = null )   {      //look for null check//      if ( preg_match('/^\~([^~]+)\~$/',$test))         $test .= ' null';               //create default message//      if ( !$message )      {         foreach ( Foul::$MAGIC_MESSAGES as $reg => $mes )         {            if ( preg_match('/'. $reg .'/i', $test ))            {               preg_match('/\~([^~]+)\~/', $test, $matches );               $message = str_replace('[[field]]',$matches[1],Foul::$MAGIC_MESSAGES[$reg]);               break;            }         }      }            $this->tests[] = new FoulTest( $this, $test, $message );   }         /*    * Method: getClientCode    * Returns javascript code of the currently configured tests for use on the client side.    *     * Parameters:    * 	$varname - the name of the javascript Foul object. Defaults to 'foul';    *     * Return:    * 	string of javascript statements with the tests and messages.    */   public function getClientCode( $varname = 'foul' )   {		$content = '';      foreach ( $this->tests as $test )      {      	$content .= "{$varname}.when('{$test->test}','{$test->message}');\r\n";      }               return $content;   }         /*    * Method: validate    * Performs the validation tests that it has been setup with against    * the passed post data.    */   public function validate()   {      $context = new FoulContext();      $this->errors = array();            foreach ( $this->tests as $index => $test )      {         $test->context = &$context;         $test->compile();         if ( $test->run( $context ) )         {            $this->errors[] = $test->message;         }      }            return empty($this->errors);   }         /*    * Method: testExists    * Return true if the test exists    */   public function testExists( $name )   {      return isset($this->custom_tests[$name]);   }         public function addTest( $name, &$obj, $method )   {      $this->custom_tests[$name] = array($obj,$method);   }         }